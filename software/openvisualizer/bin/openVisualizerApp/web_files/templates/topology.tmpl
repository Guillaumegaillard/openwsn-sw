<!doctype html>
<html>
    <head>
        <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
        %include htmlHead.tmpl
        <style type="text/css">
            #map-canvas {
                height            : 600px;
                width             : 850px;
            }
            #update_button {
                padding           : 5px;
                backgroundColor   : 'white';
                borderStyle       : 'solid';
                borderWidth       : 2px;
                textAlign         : 'center';
            }
        </style>
        <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
        <script type="text/javascript">
            
            // global variables
            var map;
            var bundleinfo;
            var newBundle;
            var motes             = [];
            var bundles           = [];
            var DATA_LOAD_PERIOD  = 5000;
            var mapLock           = false;
            var busyDrawingBundle = false;
            
            /**
            \brief Initialize the topology display
            */
            function initialize() {
                
                // map
                var mapOptions = {
                    center:    new google.maps.LatLng(37.875095,-122.257473),
                    zoom:      19,
                    mapTypeId: google.maps.MapTypeId.ROADMAP
                };
                map = new google.maps.Map(
                    document.getElementById("map-canvas"),
                    mapOptions
                );
                
                // bundleinfo
                bundleinfo = new google.maps.InfoWindow();
                google.maps.event.addListener(
                    bundleinfo,
                    'closeclick',
                    clearMapLock
                );
                
                // newBundle
                newBundle = {
                    'fromMote':  null,
                    'line':      new google.maps.Polyline(
                        {
                            geodesic:      true,
                            strokeOpacity: 0.5,
                            strokeWeight:  1
                        }
                    )
                }
                
                // load mote data
                getTopologyData();
            }
            
            /**
            \brief Retrieve the topology data from the server.
            */
            function getTopologyData() {
                
                if (mapLock==false) {
                    $.ajax({
                        url:      "/topology/data",
                        success:  handleNewData,
                    })
                    .fail(function() {
                        console.log("ERROR: could not GET topology data");
                    });
                }
                
                window.setTimeout(getTopologyData,DATA_LOAD_PERIOD);
            }
            
            /**
            \brief Update the topology using the new data.
            */
            function handleNewData(newData) {
                var i;
                var title;
                var marker;
                
                // mark all motes for deletion
                for (id in motes) {
                    motes[id].deleteMe      = true;
                }
                
                // mark all bundles for deletion
                for (i=0; i<bundles.length; i++) {
                    bundles[i].deleteMe     = true;
                }
                
                // create/update motes
                var id;
                var lat;
                var lon;
                for (i=0; i<newData.motes.length; i++) {
                    
                    id       = newData.motes[i].id;
                    lat      = newData.motes[i].lat;
                    lon      = newData.motes[i].lon;
                    
                    if (!(id in motes)) {
                        // new mote
                        
                        // create mote
                        motes[id] = {
                            'lat':      lat,
                            'lon':      lon,
                            'deleteMe': false,
                            'marker':   new google.maps.Marker({
                                            draggable:     true,
                                            map:           map,
                                            title:         id.toString()
                                        })
                        }
                        
                        // add listeners
                        google.maps.event.addListener(
                            motes[id].marker,
                            'dragstart',
                            setMapLock
                        );
                        google.maps.event.addListener(
                            motes[id].marker,
                            'dragend',
                            moteMoved
                        );
                        
                        attachRightClickCreateBundle(id);
                    }
                    
                    // update mote
                    motes[id].lat = lat;
                    motes[id].lon = lon;
                    motes[id].marker.setPosition(
                        new google.maps.LatLng(lat,lon)
                    );
                    
                    // don't delete this mote
                    motes[id].deleteMe      = false;
                }
                
                // create/update bundles
                var fromMote;
                var toMote;
                var pdr;
                var bundleIdx;
                var bundleColor;
                for (i=0; i<newData.bundles.length; i++) {
                    
                    fromMote = newData.bundles[i].fromMote;
                    toMote   = newData.bundles[i].toMote;
                    pdr      = newData.bundles[i].pdr;
                    
                    bundleIdx = getBundleIdx(fromMote,toMote);
                    
                    if (bundleIdx==null) {
                        // new bundle
                        
                        bundles.push(
                            {
                                'fromMote':    fromMote,
                                'toMote':      toMote,
                                'deleteMe':    false,
                                'line':        new google.maps.Polyline(
                                    {
                                        geodesic:      true,
                                        strokeOpacity: 1.0,
                                        strokeWeight:  2,
                                        map:           map
                                    }
                                ),
                            }
                        );
                        
                        bundleIdx = bundles.length-1;
                        
                        attachPdrInfoWindow(bundleIdx);
                    }
                    
                    // update bundle
                    bundles[bundleIdx].line.setPath(
                        [
                            new google.maps.LatLng(
                                motes[fromMote].lat,
                                motes[fromMote].lon
                            ),
                            new google.maps.LatLng(
                                motes[toMote].lat,
                                motes[toMote].lon
                            )
                        ]
                    )
                    bundles[bundleIdx].pdr = pdr;
                    setBundleColor(bundleIdx);
                    
                    // don't delete this bundle
                    bundles[bundleIdx].deleteMe  = false;
                }
                
                // delete all bundles still marked for deletion
                for (i=0; i<bundles.length; i++) {
                    if (bundles[i].deleteMe==true) {
                        bundles[i].line.setMap(null);
                        bundles.splice(i,1);
                        i--;
                    }
                }
                
                // delete all motes still marked for deletion
                for (id in motes) {
                    if (motes[id].deleteMe==true) {
                        motes[id].marker.setMap(null);
                        delete motes[id];
                        i--;
                    }
                }
            }
            
            function getBundleIdx(fromMote,toMote) {
                for (var i=0; i<bundles.length; i++) {
                    if  (
                            bundles[i].fromMote==fromMote &&
                            bundles[i].toMote==toMote
                        ) {
                        return i;
                    }
                }
                return null;
            }
            
            function setBundleColor(bundleIdx) {
                if        (bundles[bundleIdx].pdr>0.66) {
                    bundleColor = '#339933';
                } else if (bundles[bundleIdx].pdr>0.33) {
                    bundleColor = '#ff9900';
                } else {
                    bundleColor = '#ff0000';
                }
                bundles[bundleIdx].line.setOptions({strokeColor: bundleColor});
            }
            
            function attachRightClickCreateBundle(id) {
                google.maps.event.addListener(
                    motes[id].marker,
                    'rightclick',
                    function(event){
                        createNewBundle(id);
                    }
                );
            }
            
            function createNewBundle(id) {
                
                if (busyDrawingBundle==false) {
                    // start
                    
                    console.log('start at '+id);
                    
                    // lock the automatic refresh of the map
                    setMapLock();
                    
                    // remember I'm busy drawing now
                    busyDrawingBundle = true;
                    
                    // start the line
                    newBundle.fromMote = id;
                    
                    // listen to mouse moving
                    google.maps.event.addListener(
                        map,
                        'mousemove',
                        moveNewBundle
                    );
                    
                } else {
                    // stop
                    
                    console.log('stop at '+id);
                    
                    // stop listening to mouse moving
                    google.maps.event.clearListeners(
                        map,
                        'mousemove'
                    );
                    
                    // send new bundle to server
                    putNewBundle(newBundle.fromMote,id);
                }
            }
            
            function moveNewBundle(pt) {
                
                newBundle.line.setPath(
                    [
                        new google.maps.LatLng(
                            motes[newBundle.fromMote].lat,
                            motes[newBundle.fromMote].lon
                        ),
                        pt.latLng
                    ]
                )
                newBundle.line.setMap(map);
            }
            
            function putNewBundle(fromMote,toMote) {
                
                $.ajax({
                    type:    "PUT",
                    url:     "/topology/bundles",
                    data:    {
                        'fromMote': fromMote,
                        'toMote':   toMote,
                    }
                })
                .done(function( msg ) {
                    console.log("INFO: new bundle successfully PUT on server.");
                })
                .fail(function() {
                    console.log("ERROR: could not PUT new bundle to server.");
                })
                .always(function() {
                    
                    // get new data from server
                    $.ajax({
                        url:      "/topology/data",
                        success:  handleNewData,
                    })
                    .fail(function() {
                        console.log("ERROR: could not GET topology data");
                    })
                    .always(function() {
                        
                        // hide line
                        newBundle.line.setMap(null);
                        
                        // I'm not draing a new bundle anymore
                        busyDrawingBundle = false;
                        
                        // resume automated update
                        clearMapLock();
                    });
                })
            }
            
            function attachPdrInfoWindow(bundleIdx) {
                var fromMote = bundles[bundleIdx].fromMote;
                var toMote   = bundles[bundleIdx].toMote;
                var pdr      = bundles[bundleIdx].pdr;
                
                google.maps.event.addListener(
                    bundles[bundleIdx].line,
                    'click',
                    function(event){
                        setMapLock();
                        showPdrInfoWindow(fromMote,toMote,event.latLng);
                    }
                );
            }
            
            function showPdrInfoWindow(fromMote,toMote,latlon) {
                var bundleIdx;
                var content;
                
                bundleIdx = getBundleIdx(fromMote,toMote);
                
                content  = ''
                content += fromMote+'-'+toMote+':<br/>'
                content += '<input size="10" id="newPDR" value="'+bundles[bundleIdx].pdr+'">'
                content += '<button onclick="pdrUpdated('+fromMote+','+toMote+')">set PDR</button><br/>'
                content += '<button onclick="bundleDeleted('+fromMote+','+toMote+')">delete bundle</button>'
            
                bundleinfo.setContent(content);
                bundleinfo.setPosition(latlon);
                bundleinfo.open(map);
            }
            
            //=============== GUI events ======================================
            
            function setMapLock() {
                mapLock = true;
            }
            function clearMapLock() {
                mapLock = false;
            }
            
            function moteMoved() {
                var i;
                var id;
                var fromMote;
                var toMote;
                
                // update motes
                for (id in motes) {
                    motes[id].lat = motes[id].marker.getPosition().lat();
                    motes[id].lon = motes[id].marker.getPosition().lng();
                }
                
                // update bundles
                for (i=0; i<bundles.length; i++) {
                    fromMote = bundles[i]['fromMote']
                    toMote   = bundles[i]['toMote']
                    bundles[i].line.setPath(
                        [
                            new google.maps.LatLng(
                                motes[fromMote].lat,
                                motes[fromMote].lon
                            ),
                            new google.maps.LatLng(
                                motes[toMote].lat,
                                motes[toMote].lon
                            )
                        ]
                    )
                }
                
                // POST mote positions to server
                postMotesPositions();
            }
            
            function postMotesPositions() {
                var tempMotes;
                var moteId;
                
                tempMotes = []
                for (moteId in motes) {
                    tempMotes.push({
                        'id':     moteId,
                        'lat':    motes[moteId].lat,
                        'lon':    motes[moteId].lon
                    })
                }
                
                $.ajax({
                    type:    "POST",
                    url:     "/topology/motes",
                    data:    {
                        'motes': tempMotes,
                    }
                })
                .done(function( msg ) {
                    console.log("INFO: new motePositions successfully POSTed to server.");
                })
                .fail(function() {
                    console.log("ERROR: could not POST updated topology data.");
                })
                .always(function() {
                    clearMapLock();
                })
            }
            
            function pdrUpdated(fromMote,toMote) {
                var newPDR;
                
                // retrieve PDR from form
                newPDR = $("#newPDR").val();
                
                // update bundles
                // TODO: do by updating from server
                bundleIdx = getBundleIdx(fromMote,toMote)
                bundles[bundleIdx].pdr = newPDR;
                setBundleColor(bundleIdx);
                
                // POST bundle PDR to server
                postBundlePDR(bundleIdx);
            }
            
            function bundleDeleted(fromMote,toMote) {
                $.ajax({
                    type:    "DELETE",
                    url:     "/topology/bundles",
                    data:    {
                        'fromMote': fromMote,
                        'toMote':   toMote,
                    }
                })
                .done(function( msg ) {
                    console.log("INFO: bundle DELETEed from server.");
                })
                .fail(function() {
                    console.log("ERROR: could not DELETE bundle.");
                })
                .always(function() {
                    
                    // get new data from server
                    $.ajax({
                        url:      "/topology/data",
                        success:  handleNewData,
                    })
                    .fail(function() {
                        console.log("ERROR: could not GET topology data");
                    })
                    .always(function() {
                        
                        // close info window
                        bundleinfo.close();
                        
                        // resume automated update
                        clearMapLock();
                    });
                })
            }
            
            function postBundlePDR(bundleIdx) {
                var tempMotes;
                var moteId;
                
                tempMotes = []
                for (moteId in motes) {
                    tempMotes.push({
                        'id':     moteId,
                        'lat':    motes[moteId].lat,
                        'lon':    motes[moteId].lon
                    })
                }
                
                $.ajax({
                    type:    "POST",
                    url:     "/topology/bundles",
                    data:    {
                        'fromMote': bundles[bundleIdx].fromMote,
                        'toMote':   bundles[bundleIdx].toMote,
                        'pdr':      bundles[bundleIdx].pdr,
                    }
                })
                .done(function( msg ) {
                    console.log("INFO: new PDR successfully POSTed to server.");
                })
                .fail(function() {
                    console.log("ERROR: could not POST updated PDR.");
                })
                .always(function() {
                    bundleinfo.close();
                    clearMapLock();
                })
            }
            
            //=============== main ============================================
            
            google.maps.event.addDomListener(window, 'load', initialize);
            
        </script>
    </head>
    <body>
        %include menuHeader.tmpl
        <div id="map-canvas"/>
    </body>
</html>